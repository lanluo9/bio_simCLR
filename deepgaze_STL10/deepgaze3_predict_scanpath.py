# -*- coding: utf-8 -*-
"""DeepGaze3_predict_scanpath.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/192iJMeQt-DME3vUASXehgM_XKiHFnAtD

# install
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.misc import face
from scipy.ndimage import zoom
from scipy.special import logsumexp
from tqdm import tqdm
import sys
import gc
from IPython.display import clear_output

import torch
from torchvision import datasets, transforms
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F

# %load_ext autoreload 
# %autoreload 2

# # TODO: load downloaded files from google drive
# from google.colab import drive
# drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/matthias-k/DeepGaze
# %cd /content/DeepGaze/deepgaze_pytorch
sys.path.append("/content/DeepGaze")
import deepgaze_pytorch

!wget https://github.com/matthias-k/DeepGaze/releases/download/v1.0.0/centerbias_mit1003.npy
centerbias_template = np.load('centerbias_mit1003.npy') # load precomputed centerbias log density (from MIT1003) over a 1024x1024 image
DEVICE = 'cuda'

"""# combine
1. use deepgaze 2e to predict a fixation distribution (without fixation history input)
2. draw 4 fixations far away from each other to fake a fixation history
3. feed this fake fixation history to deepgaze 3 to simulate rest of the scanpath
"""

model_deepgaze2 = deepgaze_pytorch.DeepGazeIIE(pretrained=True).to(DEVICE)
model_deepgaze3 = deepgaze_pytorch.DeepGazeIII(pretrained=True).to(DEVICE)


def deepgaze2_pred(image, model=model_deepgaze2):
  '''use deepgaze 2e to predict a fixation distribution (without fixation history input)'''
  centerbias = zoom(centerbias_template, \
                    (image.shape[0]/centerbias_template.shape[0], image.shape[1]/centerbias_template.shape[1]), \
                    order=0, mode='nearest') # rescale to match image size
  centerbias -= logsumexp(centerbias) # renormalize log density
  centerbias_tensor = torch.tensor([centerbias]).to(DEVICE)

  image_tensor = torch.tensor([image.transpose(2, 0, 1)]).to(DEVICE)
  log_density_prediction = model(image_tensor, centerbias_tensor) # predicted log density for the next fixation location 

  del model, centerbias_tensor, image_tensor
  gc.collect()
  torch.cuda.empty_cache()
  
  return log_density_prediction


def draw_fix_from_pred(log_density_prediction, nfix=1):
  '''draw 4 fixations to fake a fixation history'''

  fix_dist = log_density_prediction.detach().cpu().numpy()[0, 0]
  fix_dist = np.exp(fix_dist)
  assert math.isclose(fix_dist.sum(), 1) # validate 2d dist of prob sum to 1

  flat = fix_dist.flatten() # sample from fix_dist
  sample_index = np.random.choice(a=flat.size, p=flat, size=nfix)  # sample an index from the 1D array with the probability distribution from the original array
  adjusted_index = np.unravel_index(sample_index, fix_dist.shape) # Take this index and adjust it so it matches the original array
  fixations_x = adjusted_index[1]
  fixations_y = adjusted_index[0] # height = axis 0 = y

  return fixations_x, fixations_y


def deepgaze3_pred(image, fixation_history_x, fixation_history_y, model=model_deepgaze3, nfix_total=20):
  '''
  feed fake fixation history to deepgaze 3 to simulate rest of the scanpath
  use log_density_prediction to draw next fixation, update log_density_prediction, until reach nfix_total
  arg:
    image: np.array of shape (xpix, ypix, channel)
    fixation_history_x
    fixation_history_y
    nfix_total: total fixation needed per image, including 4 steps of fake fixation history
  return:
    fixation_history_x
    fixation_history_y
    log_density_prediction: pred prob of next fix
  '''
  centerbias = zoom(centerbias_template, \
                    (image.shape[0]/centerbias_template.shape[0], image.shape[1]/centerbias_template.shape[1]), \
                    order=0, mode='nearest') # rescale to match image size
  centerbias -= logsumexp(centerbias) # renormalize log density
  centerbias_tensor = torch.tensor([centerbias]).to(DEVICE)

  image_tensor = torch.tensor([image.transpose(2, 0, 1)]).to(DEVICE) 
  x_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
  y_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
  log_density_prediction = model(image_tensor, centerbias_tensor, x_hist_tensor, y_hist_tensor)

  nstep = nfix_total - 4 # subtract 4 steps of fake history, simulate rest of the fixations
  for i in range(nstep):

    fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=1) # predict next fixation
    fixation_history_x = np.append(fixation_history_x, fixations_x)
    fixation_history_y = np.append(fixation_history_y, fixations_y)
    
    x_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
    y_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
    log_density_prediction = model(image_tensor, centerbias_tensor, x_hist_tensor, y_hist_tensor)

  del model, centerbias_tensor, image_tensor, x_hist_tensor, y_hist_tensor
  gc.collect()
  torch.cuda.empty_cache()

  return fixation_history_x, fixation_history_y, log_density_prediction

# log_density_prediction = deepgaze2_pred(face())
# f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
# axs[0].imshow(face())
# axs[0].set_axis_off()
# axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
# axs[1].set_axis_off()


# fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=4)
# fixation_history_x = fixations_x
# fixation_history_y = fixations_y

# min 4 fixations in history: https://github.com/matthias-k/DeepGaze/blob/c33b89f08016e41e68cec4e4d9f1a73a14211386/deepgaze_pytorch/deepgaze3.py#L106
# `included_fixations=[-1, -2, -3, -4]`
# if more fixation points are provided but always at similar positions, the model always stays at the same spot
# TODO: ensure 4 fixations are far away from each other / inhibition of return


# fixation_history_x, fixation_history_y, log_density_prediction = deepgaze3_pred(face(), \
#                                                                                 fixation_history_x, fixation_history_y, \
#                                                                                 nfix_total=20)
# f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
# axs[0].imshow(face())
# axs[0].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[0].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[0].set_axis_off()
# axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
# axs[1].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[1].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[1].set_axis_off()


# # after running the pipeline down below:
# f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
# axs[0].imshow(images_np)
# axs[0].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[0].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[0].set_axis_off()
# axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
# axs[1].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[1].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[1].set_axis_off()

"""# deepgaze try on STL10"""

# %%timeit

dataset = datasets.STL10("Dataset", split="unlabeled", download=True, \
                         transform=transforms.ToTensor(),) # download takes 2-4 min
dataloader = DataLoader(dataset, batch_size=1, shuffle=False, \
                        drop_last=False) #TODO: batch size back to larger (75)

nfix_total = 20
scanpath_arr = np.zeros((len(dataset), nfix_total, 2)) # n img, n fix per img, x & y

counter = 0
counter_start = 0
counter_end = len(dataset) / 5

for images, _ in tqdm(dataloader): # print(images.shape) # singleton, chan, x, y
  if counter < counter_start:
    pass

  img_large = F.interpolate(images.to('cuda'), [256, 256]) # interpolate to increase scanpath pred perf, 256 seems best
  img_large = torch.transpose(img_large, 1, 3)
  img_large = torch.transpose(img_large, 1, 2) # print(img_large.shape) # batch_size x height x width x 3 
  # TODO: increase batch size

  images_np = img_large.cpu().detach().numpy() # tensor to np
  images_np = np.squeeze(images_np) # print(images_np.shape, type(images_np)) # height x width x 3
  # plt.matshow(images_np[:,:,0]) # ensure img is standing upright

  log_density_prediction = deepgaze2_pred(images_np)
  fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=4)
  del img_large, log_density_prediction; torch.cuda.empty_cache()
  fixation_history_x, fixation_history_y, log_density_prediction = deepgaze3_pred(images_np, \
                                                                                  fixations_x, fixations_y, \
                                                                                  nfix_total=nfix_total)
  scanpath_arr[counter,:,0] = fixation_history_x # width
  scanpath_arr[counter,:,1] = fixation_history_y # height

  gc.collect()
  torch.cuda.empty_cache()
  # clear_output(wait=True)
  # print(torch.cuda.is_available())
  # print(torch.cuda.memory_allocated() / 1024**3)
  # print(torch.cuda.memory_reserved() / 1024**3)

  counter += 1
  if counter >= counter_end: # result doesn't contain endpoint, only contain start point
    break

np.save(f"/content/stl10_unlabeled_scanpath_deepgaze_{counter_start}_{counter_end}.npy", scanpath_arr)

# %time
# counter = 0
# for images, _ in tqdm(dataloader): # print(images.shape) # singleton, chan, x, y
#   counter += 1
#   if counter > 100000 / 5 * 4:
#     break

# 30.1/5 * 100000 / 3600/24, 132/24 # 5-7 days to run this if batch size = 1, without parallelization