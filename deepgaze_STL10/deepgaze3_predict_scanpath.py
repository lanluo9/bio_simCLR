# -*- coding: utf-8 -*-
"""DeepGaze3_predict_scanpath.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/192iJMeQt-DME3vUASXehgM_XKiHFnAtD

# install
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.misc import face
from scipy.ndimage import zoom
from scipy.special import logsumexp
from tqdm import tqdm
import sys
import gc

import torch
from torchvision import datasets, transforms
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F

# %load_ext autoreload 
# %autoreload 2

# # TODO: load downloaded files from google drive
# from google.colab import drive
# drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/matthias-k/DeepGaze
# %cd /content/DeepGaze/deepgaze_pytorch
sys.path.append("/content/DeepGaze")
import deepgaze_pytorch

!wget https://github.com/matthias-k/DeepGaze/releases/download/v1.0.0/centerbias_mit1003.npy 
# precomputed centerbias log density (from MIT1003) over a 1024x1024 image
centerbias_template = np.load('centerbias_mit1003.npy') # load precomputed centerbias log density (from MIT1003) over a 1024x1024 image
DEVICE = 'cuda'

"""# combine
1. use deepgaze 2e to predict a fixation distribution (without fixation history input)
2. draw 4 fixations far away from each other to fake a fixation history
3. feed this fake fixation history to deepgaze 3 to simulate rest of the scanpath
"""

model_deepgaze2 = deepgaze_pytorch.DeepGazeIIE(pretrained=True).to(DEVICE)

def deepgaze2_pred(image, model=model_deepgaze2):
  '''use deepgaze 2e to predict a fixation distribution (without fixation history input)'''
  centerbias = zoom(centerbias_template, \
                    (image.shape[0]/centerbias_template.shape[0], image.shape[1]/centerbias_template.shape[1]), \
                    order=0, mode='nearest') # rescale to match image size
  centerbias -= logsumexp(centerbias) # renormalize log density
  centerbias_tensor = torch.tensor([centerbias]).to(DEVICE)

  image_tensor = torch.tensor([image]).to(DEVICE) # .transpose(2, 0, 1)
  # print(image_tensor.shape)
  log_density_prediction = model(image_tensor, centerbias_tensor) # predicted log density for the next fixation location 

  del model, centerbias_tensor, image_tensor
  gc.collect()
  torch.cuda.empty_cache()
  
  return log_density_prediction

# log_density_prediction = deepgaze2_pred(face())
# f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
# axs[0].imshow(face())
# axs[0].set_axis_off()
# axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
# axs[1].set_axis_off()

def draw_fix_from_pred(log_density_prediction, nfix=1):
  '''draw 4 fixations to fake a fixation history'''

  fix_dist = log_density_prediction.detach().cpu().numpy()[0, 0]
  fix_dist = np.exp(fix_dist)
  assert math.isclose(fix_dist.sum(), 1) # validate 2d dist of prob sum to 1

  flat = fix_dist.flatten() # sample from fix_dist
  sample_index = np.random.choice(a=flat.size, p=flat, size=nfix)  # sample an index from the 1D array with the probability distribution from the original array
  adjusted_index = np.unravel_index(sample_index, fix_dist.shape) # Take this index and adjust it so it matches the original array
  fixations_x = adjusted_index[1]
  fixations_y = adjusted_index[0] # height = axis 0 = y

  return fixations_x, fixations_y

# fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=4)
# fixation_history_x = fixations_x
# fixation_history_y = fixations_y

# min 4 fixations in history: https://github.com/matthias-k/DeepGaze/blob/c33b89f08016e41e68cec4e4d9f1a73a14211386/deepgaze_pytorch/deepgaze3.py#L106
# `included_fixations=[-1, -2, -3, -4]`
# if more fixation points are provided but always at similar positions, the model always stays at the same spot
# TODO: ensure 4 fixations are far away from each other / inhibition of return

model_deepgaze3 = deepgaze_pytorch.DeepGazeIII(pretrained=True).to(DEVICE)

def deepgaze3_pred(image, fixation_history_x, fixation_history_y, model=model_deepgaze3, nfix_total=20):
  '''
  feed fake fixation history to deepgaze 3 to simulate rest of the scanpath
  use log_density_prediction to draw next fixation, update log_density_prediction, until reach nfix_total
  arg:
    image
    fixation_history_x
    fixation_history_y
    nfix_total: total fixation needed per image, including 4 steps of fake fixation history
  return:
    fixation_history_x
    fixation_history_y
    log_density_prediction: pred prob of next fix
  '''
  centerbias = zoom(centerbias_template, \
                    (image.shape[0]/centerbias_template.shape[0], image.shape[1]/centerbias_template.shape[1]), \
                    order=0, mode='nearest') # rescale to match image size
  centerbias -= logsumexp(centerbias) # renormalize log density
  centerbias_tensor = torch.tensor([centerbias]).to(DEVICE)

  image_tensor = torch.tensor([image]).to(DEVICE) # .transpose(2, 0, 1)
  x_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
  y_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
  log_density_prediction = model(image_tensor, centerbias_tensor, x_hist_tensor, y_hist_tensor)

  nstep = nfix_total - 4 # subtract 4 steps of fake history, simulate rest of the fixations
  for i in range(nstep):

    fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=1) # predict next fixation
    fixation_history_x = np.append(fixation_history_x, fixations_x)
    fixation_history_y = np.append(fixation_history_y, fixations_y)
    
    x_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
    y_hist_tensor = torch.tensor([fixation_history_x[model.included_fixations]]).to(DEVICE)
    log_density_prediction = model(image_tensor, centerbias_tensor, x_hist_tensor, y_hist_tensor)

  del model, centerbias_tensor, image_tensor, x_hist_tensor, y_hist_tensor
  gc.collect()
  torch.cuda.empty_cache()

  return fixation_history_x, fixation_history_y, log_density_prediction


# fixation_history_x, fixation_history_y, log_density_prediction = deepgaze3_pred(face(), \
#                                                                                 fixation_history_x, fixation_history_y, \
#                                                                                 nfix_total=20)
# f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
# axs[0].imshow(face())
# axs[0].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[0].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[0].set_axis_off()
# axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
# axs[1].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
# axs[1].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
# axs[1].set_axis_off()

"""# deepgaze try on STL10"""

dataset = datasets.STL10("Dataset", split="unlabeled", download=True, transform=transforms.ToTensor(),) # download takes 2-4 min
dataloader = DataLoader(dataset, batch_size=1, shuffle=False, drop_last=False) #TODO: batch size back to larger (75)
# scanpath_arr = np.zeros((len(dataset), 1, 96, 96), dtype=np.float32)
# print(scanpath_arr.shape)

for images, _ in tqdm(dataloader):
  print(images.shape) # singleton, chan, x, y

  img_large = F.interpolate(images.to('cuda'), [256, 256]) # interpolate to match precomputed centerbias log density (from MIT1003)
  # img_large = images
  # print(img_large.shape)

  # img_large = torch.transpose(img_large, 0, 3)
  # img_large = torch.transpose(img_large, 1, 2)
  # img_large = torch.transpose(img_large, 0, 1)
  # print(img_large.shape) # x, y, channel, batch_size

  # img_large = torch.transpose(img_large, 1, 3)
  # img_large = torch.transpose(img_large, 1, 2)
  print(img_large.shape) # batch_size x height x width x 3

  images_np = img_large.cpu().detach().numpy() # tensor to np
  del images, img_large
  torch.cuda.empty_cache()

  images_np = np.squeeze(images_np)
  print(images_np.shape)
  plt.matshow(images_np[0,:,:])
  break

import deepgaze_pytorch
log_density_prediction = deepgaze2_pred(images_np) # uses 7.73 GB GPU RAM up til now
fixations_x, fixations_y = draw_fix_from_pred(log_density_prediction, nfix=4)
del log_density_prediction
torch.cuda.empty_cache()
fixation_history_x, fixation_history_y, log_density_prediction = deepgaze3_pred(images_np, \
                                                                                fixations_x, fixations_y, \
                                                                                nfix_total=20)
gc.collect()
torch.cuda.empty_cache()
print(torch.cuda.is_available())
print(torch.cuda.memory_allocated() / 1024**3)
print(torch.cuda.memory_reserved() / 1024**3)

image = images_np
centerbias = zoom(centerbias_template, \
                  (image.shape[0]/centerbias_template.shape[0], image.shape[1]/centerbias_template.shape[1]), \
                  order=0, mode='nearest') # rescale to match image size
centerbias -= logsumexp(centerbias) # renormalize log density
centerbias_tensor = torch.tensor([centerbias]).to(DEVICE)

model = deepgaze_pytorch.DeepGazeIIE(pretrained=True).to(DEVICE)
image_tensor = torch.tensor([image]).to(DEVICE) # .transpose(2, 0, 1)
image_tensor = torch.squeeze(image_tensor)
print(image_tensor.shape)
log_density_prediction = model(image_tensor, centerbias_tensor) # predicted log density for the next fixation location

f, axs = plt.subplots(nrows=1, ncols=2, figsize=(8, 3))
axs[0].imshow(images_np)
axs[0].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
axs[0].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
axs[0].set_axis_off()

axs[1].matshow(log_density_prediction.detach().cpu().numpy()[0, 0])  # first image in batch, first (and only) channel
axs[1].plot(fixation_history_x, fixation_history_y, 'o-', color='red')
axs[1].scatter(fixation_history_x[-1], fixation_history_y[-1], 100, color='yellow', zorder=100)
axs[1].set_axis_off()

# csr = 0
# # for images, _ in tqdm(dataloader):
# #   img_tsr = F.interpolate(images.to('cuda'), [512, 512]) 

# #   with torch.no_grad():
# #     salmap = model(img_tsr)

#   # salmap_small = F.interpolate(salmap, [96, 96]).cpu().numpy()
#   # csr_end = csr + images.shape[0]
#   # salmap_arr[csr:csr_end, :, :, :] = salmap_small
#   # csr = csr_end

# np.save("/content/Dataset/stl10_unlabeled_salmaps_salicon.npy", salmap_arr)